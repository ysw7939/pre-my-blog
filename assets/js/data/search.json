[ { "title": "객체 지향 설계와 스프링", "url": "/posts/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81/", "categories": "Spring", "tags": "SOLID, OCP, LSP, ISP, DIP", "date": "2023-05-05 00:00:00 +0900", "snippet": "객체 지향 설계와 스프링스프링이란여러가지의 기술의 모음이라고 할수 있다. 스프링 데이터 : JPA, DB에 있는 기본적인 CRUD를 편리하게 사용할수 있도록 도와준다.스프링 시큐리티 : 보안과 관련된 설정을 도와준다.스프링 세션 : 세션에 관련된 설정을 도와준다.스프링 배치 : 배치 처리를 도와준다.스프링 Rest Docs : API 문서화를 편하게 해준다.….스프링 부트 Tomcat과 같은 별도의 웹서버를 내장에서 별도의 웹 서버를 설치하지 않아도 된다. starter 라이브러리를 가져올때 starter를 사용하면 하나를 가져올때 필요한 부수적인 라이브러리를 같이 빌드한다. 서드파티(3rd parth) 자주사용되는 메이저 라이브러리와의 버전호환성을 관리해준다. 애플리케이션의 상태를 숫자 측정값으로 나타낼수 있는 메트릭, 모니터링 기능을 제공해 준다. 관례에 의한 모든 초기 설정이 되어있어서 특정 다른부분만 커스텀마이즈 하여 사용할수 있다.SOLIDSRP 단일 책임 원칙Single responsilbility principle 한 클래스는 하나의 책임만 가져야한다. 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것이다.예) UI변경, 객체의 생성과 사용을 분리OCP 개방-폐쇄 원칙Open/closed principle 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다. 다형성을 활용하면 역할과 구현을 나눌수 있다 인터페이스를 이용하여 역할을 정의하고 새로운 클래스를 만들어 기능을 구현한다. 사용하고 있는 인터페이스는 그대로 있기 때문에 기존 코드에 변경을 주지 않는다.문제점DI를 사용하지 않으면 클라이언트, 즉 소프트웨어가 구현 객체를 변경할려면 코드를 변경해야한다.다형성을 사용했지만 OCP 원칙을 지킬 수 없다.LSP 리스코프 치환 원칙Liskov substitution principle 프로그램의 객체는 인터페이스 규약을 다 지켜야한다. 주문받는 역할을 하기로 했으면 주문받는 역할을 하는 객체가 있어야한다.예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능을 한다 만약 뒤로 가게 구현한다면 LSP를 위반한 것이다. 느리더라도 앞으로 가기만 한다면 LSP를 위반하지 않는다.ISP 인터페이스 분리 원칙Interface segregation principle 여러 클라이언트를 위한 범용적인 인터페이스 보다 특정 클라이언트를 위한 인터페이스 여러개가 낫다. 여러가지 인터페이스로 분리하여 관리하게되면 A인터페이스를 변경하더라도 B인터페이스가 영향을 받지 않는다.DIP 의존관계 역전 원칙Dependency inversion principle 구현 클래스에 의존하지 말고 역할을 정의한 인터페이스에 의존해야한다. 객체 세상도 클라이언트가 인터페이스에 의존해야 구현체를 쉽게 변경할수 있다. 구현체에 의존하게 되면 수정해야 될 부분이 많아져 변경이 어려워진다.문제점DIP도 OCP에서 얘기 했던 것과 마찬가지로 다형성을 사용하더라도 클라이언트가 구현 클래스를 직접선택한다. 인터페이스에 의존하지만 동시에 구현클래스도 의존하게 되는 것이다. DIP 원칙을 지킬수 없다.스프링OCP와 DIP 원칙을 지키기 위해선 DI(Dependency Injection)를 사용할 수 있어야 한다. 클라이언트 코드의 변경 없이 기능 확장 부품을 교체하듯이 컴포넌트로 개발정리 모든 설계에 역할과 구현을 분리하자 애플리케이션 설계도 역할만 정해두고 구현은 언제든지 다른것으로 변경할 수 있도록 만드는 것이 좋은 객체지향 설계이다.주의할점인터페이스를 무분별하게 사용할 경우 한번에 구현클래스를 보기가 힘들어 코드의 가독성이 떨어질수있다.추천하는 방법으로는 변경될지 않을것 같은 클래스는 인터페이스를 설계하지 않고 추후에 리펙터링을 하는것이 좋다." }, { "title": "HTTP 기본", "url": "/posts/HTTP-%EA%B8%B0%EB%B3%B8/", "categories": "HTTP", "tags": "sateful, stateless, 비연결성, HTTP 메시지 구조", "date": "2023-04-26 00:00:00 +0900", "snippet": "HTTP 기본HTTPHyper Text Transfer Protoco모든 형태의 데이터를 HTTP 메시지로 전송한다. HTML, TEXT IMAGE, 음성, 영상, 파일 JSON, XML (API)기반 프로토콜 TCP: HTTP/1.1, HTTP/2 UDP: HTTP/3 현재 HTTP/1.1 주로 사용한다.HTTP 특징클라이언트 서버 구조 Request Response 구조 클라이언트는 UI와 사용성에 대해 고민한다. 서버는 비지니스 로직과 데이터를 관리한다.Stateful상태 유지: 중간에 다른 서버로 변경되서는 안된다.서버가 이전상태의 내용을 보존한다.Stateless무상태: 중간에 다흔 서버로 변경되어도 된다.서버가 이전상태의 내용을 보존하지 않는다.비 연결성장점 HTTP는 기본이 연결을 유지하지 않는 모델이다. 일반적으로 초 단위 이하의 빠른 속도로 응답한다. 수천명이 서비스를 이용하더라도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매주 적다. 서버 자원을 매우 효율적으로 사용할 수 있다.단점과 극복 매번 TCP/IP 연결을 새로 맺어야 한다. - 3 way handshake 시간 추가 웹 브라우저로 사이트를 요청하면 HTML 뿐 아니라 자바스크립트 css 추가 이미지 등 수많은 자원이 함께 다운로드 된다. 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결한다. HTTP/2, HTTP/3 더 많은 최적화HTTP 메시지 구조start-line 시작라인header 헤더empty line 공백 라인 CRLF (엔터)message body시작 라인request-line / status-linerequest-line = method SP(공백) request-target SP HTTP-version CRLF(엔터)status-line = HTTP-version SP status-code SP reason-phrase CRLFHTTP 버전HTTP 상태 코드: 요청 성공, 실패를 나타냄200: 성공400: 클라이언트 요청 오류500: 서버 내부 오류 이유 문구 : 사람이 이해할 수 있는 짧은 상태 코드 설명 글헤더header-field = field-name “:” OWS field -value OWS (OWS는 띄어쓰기 허용을 의미한다)field-name은 대소문자 구문이 없다. HTTP 전송에 필요한 모든 부가정보 예) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 요청 클라이언트(브라우저) 정보, 서버 애플리케이션 정보 … 표준 헤더가 너무 많다. 필요시 임의의 헤더 추가가 가능하다. helloworld: hihi 메시지 바디 실제 전송할 데이터 HTML 문서, 이미지 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송이 가능하다." }, { "title": "URI와 웹 브라우저 요청 흐름", "url": "/posts/URI%EC%99%80-%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%9A%94%EC%B2%AD-%ED%9D%90%EB%A6%84/", "categories": "HTTP", "tags": "URI, URL, URN", "date": "2023-04-24 00:00:00 +0900", "snippet": "URI와 웹 브라우저 요청 흐름URI(Uniform Resource Identifier)uri 안에는 url 과 urn이 포함되어있다.Uniform : 리소스 식별하는 통일된 방식Resource : 자원, URI로 식별할 수 있는 모든 것(제한 없음)Identifier : 다른 항목과 구분하는데 필요한 정보URL(Resource Locator)리소스의 위치를 의미한다.URN(Resource Name)리소스의 이름을 의미한다. 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되어있지 않다.URL 문법scheme주로 프로토콜을 사용한다.프로토콜 : 클라이언트와 서버간의 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙을 의미한다. 예) http, https, ftp 등등http 포트는 80 포트를 기본값으로 사용 https는 443포트를 기본으로 사용한다.host호스트명도메인명 또는 IP 주소를 직접 사용가능하다.path리소스 경로, 계층적 구조querykey=value 형태query parameter, query string 등으로 불린다.웹 브러우저 요청 흐름 웹 브라우저가 HTTP 메시지를 생성한다. SOCKET 라이브러리를 통해 전달한다. TCP/IP 연결 (IP&lt; PORT) 데이터 전달 TCP/IP 패킷 생성, HTTP 메시지 포함한다." }, { "title": "[HTTP]인터넷 프로토콜", "url": "/posts/%EC%9D%B8%ED%84%B0%EB%84%B7-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/", "categories": "HTTP", "tags": "HTTP, TCP, 3way handshake, IP, UDP", "date": "2023-04-23 00:00:00 +0900", "snippet": "인터넷 네트워크인터넷 프로토콜인터넷 세상은 서로 통신을 하기위해 ip주소를 받게된다. 인터넷 프로토콜은 지정된 ip주소로 패킷이라는 통신 단위를 통해 데이터를 전달 할수있는 역할을 한다.전송된 패킷은 여러개의 노드를 거쳐서 목적지 까지 이동하게 된다.IP 프로토콜의 한계 비연결성 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷이 전송된다. 비신뢰성 중간에 패킷이 사라지는 문제나 패킷이 순서대로 오지 않는 문제를 해결할 수 없다. 프로그램 구분 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면 구분할수 있는 방법이 없다. TCP전송 제어 프로토콜(Transmission Control Protocol) 연결 지향 상대와 연결한후 전송한다. 3 way handshake 데이터 전달 보증 전송된 패킷이 중간에 누락되어도 알 수 있다. 순서 보장 전송된 패킷의 순서가 올바르지 못할 경우 클라이언트에게 다시보내라는 요청을 한다. 3 way handshake송신측(클라이언트)에서 서버에 최초 SYN 플래그로 상대에게 접속함과 동시에 패킷을 보내고, 수신측에서는 ‘SYN/ACK’ 플래그로 송신측에 접속함과 동시에 패킷을 수신한 사실을 알린다. 마지막으로 송신측이 ‘ACK’ 플레그릴 보내 패킷 교환이 완료되었을을 전달한다.UDP(Userr Datagram Protocol)사용자 데이터그램 프로토콜 기능이 거의 없고, 데이터 보증과 순서 보장이 안된다. 전반적으로 IP와 거의 같다. IP와 가장 큰 차이점은 PORT의 유무 이다.전송받은 메세지에 대해서 간단하게 검증하는 체크섬이 추가 되었다.TCP는 3 way handshake에 소모하는 시간이 길고 최적화 하기에 어렵다.UDP는 단순하고 빠르기 때문에 애플리케이션딴에서 추가 작업으로 최적화가 가능하다." }, { "title": "[JPA]영속성 관리", "url": "/posts/%EC%98%81%EC%86%8D%EC%84%B1-%EA%B4%80%EB%A6%AC/", "categories": "JAP", "tags": "영속성 관리, 엔티티 팩토리, 엔티티 메니저, 병합, 변경감지, 엔티티 수정", "date": "2023-03-29 00:00:00 +0900", "snippet": "영속성 관리엔티티 팩토리EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"jpabook\");META-INF/persistence.xml 에 있는 정보를 바탕으로 엔티티 펙토리를 생성한다.엔티티 매니저 팩토리는 이름 그대로 엔티티 메니저를 만드는 공장이다.엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로다른 스레드 간에 공유해도 되지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 생기므로 스레드간에 공유해서는 안된다.영속성 컨텍스트란‘엔티티를 영구 저장하는 환경’이라는 뜻이다. 엔티티 메니저로 엔티티를 조회하거나 저장하게되면 엔티티메니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.em.persist(member) // 영속성 컨텍스트 등록persist() 메소드는 엔티티 메니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장한다.엔티티의 생명주기 비영속(new/transient): 영속성 컨텍스트와 전혀 관계가 없는 상태 영속(managed): 영속성 컨텍스트에 저장된 상태 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태 삭제(removed): 삭제된 상태영속성 컨텍스트가 관리하는 엔티티를 영속 상태라 한다. 영속 상태라는 것은 영속성 컨텍스트에 의해 관리된다는 뜻이다.영속성 컨텍스트의 특징영속성 컨텍스트는 엔티티를 식별자 값(테이블의 기본 키(pk)와 매핑한 값)으로 구분한다. 따라서 영속 상태는 식별자 값이 반드시 있어야한다.엔티티 조회영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라한다. 영속 상태의 엔티티는 모두 이곳에 저장된다. map 형식으로 key는 @id 가된다. 값은 엔티티 인스턴스다.만약 em.find() 메소드를 전송받았을때 먼저 1차 캐시에서 엔티티를 찾고 만약 찾는 엔티티가 1차 캐시에 없으면 데이터 베이스에서 조회하게 된다. (DB에서 조회한후 1차캐시에 저장후 결과값 반환)영속 엔티티의 동일성 보장Member a = em.find(Member.class, id);Member b = em.find(Member.class, id);반복해서 호출해도 영속성 컨텍스트는 1차 캐시에 있는 엔티티 인스턴스를 반환한다. 따라서 둘은 같인 인스턴스다. 따라서 영속성 컨텍스트는 성는아상 이점과 엔티티의 동일성을 보장한다.엔티티 수정SQL 수정 쿼리는 프로젝트가 점점 커지고 요구사항이 늘어나면서 수정 쿼리가 점점 추가된다.쿼리가 늘어나게되면 비즈니스 로직을 분석하기 위해 SQL을 계속 확인해야 한다.변경 감지JPA에서 엔티티를 수정하는 방법에 대해서 알아보자JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라 한다.그리고 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다. →변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다. →쓰지 지연 저장소의 SQL을 데이터베이스에 보낸다. →데이터베이스 트랜잭션을 커밋한다.변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.JPA는 기본적으로 수정된 필드만 수정하는 것이 아니라 모든 필드를 업데이트 한다.병합 merge()준영속 상태의 엔티티를 다시 영속상태로 변경 하려면 병합을 사용하면된다. 이때 주의할 점은 기존의 준영속상태 엔티티를 영속상태로 만드는 것이 아니라 준영속 상태였던 엔티티의 정보를 받아서 새로운 영속상태의 엔티티를 만드는 것이다.package jpabook.start;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.EntityTransaction;import javax.persistence.Persistence;public class ExamMergeMain { static EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"jpabook\"); public static void main(String[] args) { Member member = createMember(\"memberA\", \"회원1\"); member.setUsername(\"회원명변경\"); // 준영속 상태에서 변경하는것 meargeMember(member); } private static void meargeMember(Member member) { EntityManager em2 = emf.createEntityManager(); EntityTransaction tx2 = em2.getTransaction(); tx2.begin(); Member margeMember = em2.merge(member); //비영속 상태 member엔티티 정보를 가지고 새로운 member엔티티 생성 // 즉 수정된 이름으로 작성 되어있던 member엔티티 정보를 가지고 생성하게되는 것이다. tx2.commit(); // 컷밋하기 전 jpa는 자동으로 flush()가 호출되는데 // 그때 저장해 두었던 스냅샷과 비교해서 수정된 부분이잇으면 수정쿼리를 지연 sql에 보내게된다. //준영속 상태 System.out.println(\"member = \" + member. getUsername() ) ; //영속 상태 System.out.println(\"mergeMember = \"+ margeMember.getUsername() ); System.out.println(\"em2 contains member = \"+ em2.contains(member) ) ; System.out.println(\"em2 contains mergeMember =\" + em2.contains(margeMember) ) ; em2.close() ; //==영속성 컨텍스트2 종료 ==/ } private static Member createMember(String id, String username) { EntityManager em1 = emf.createEntityManager(); EntityTransaction tx1 = em1.getTransaction(); tx1.begin(); Member member = new Member(); member.setId(id); member.setUsername(username); em1.persist(member); //스냅샷 등록 tx1.commit(); em1.close(); // 영속성 컨텍스트1 종료, // member 엔티티는 준영속 상태가 된다. return member; }} 출력결과 member = 회원명변경 mergeMember = 회원명변경 em2 contains member = false em2 contains mergeMember =true " }, { "title": "JVM", "url": "/posts/StudyHalle1/", "categories": "JAVA", "tags": "바이트코드, JIT컴파일러, 자바컴파일방법, 자바실행방법, JRE와 JDK차이, JVM 구성요소", "date": "2022-06-27 00:00:00 +0900", "snippet": "스터디 할래 1주차자산 유형: JDK와 JRE차이, JIT 컴파일러란?, JVM, JVM 구성 요소, 바이트코드란?, 실행하는 방법, 컴파일 하는 방법JVMJava Virtual Machine 의 약자다. 자바 이전에 C언어는 기계어로 번역하는 작업 즉, 컴파일 작업을 운영체제 마다 다른 컴파일러로 컴파일 하는 작업을 거쳐야 했다. 하지만 자바는 자바컴파일러를 거쳐 운영체제로 가기전에 JVM이 사이에서 중개자 역할을 한다. JVM은 운영체제가 뭐가 되었든 상관없이 프로그램을 실행할 수 있도록 도와주는 역할을 한다.JDK와 JRE의 차이java9버전 부터는 JRE가 사라지고 JDK만 있다.JDK자바의 JDK는 JRE를 포함에 자바를 실행하고 프로그래밍에 필요한 모든 구성요소를 갖춘 SDK(Softwar DevelopmentKit)이다.자바 개발 시 필요한 라이브러리들과 자바를 컴파일 하는 javac, 자바 소스파일을 주석및 어노테이션을 이용해 html파일로 문서화 할수 있는 javadoc등이 있다.JRE자바를 실행하고 동작하기 위해 필요한 라이브러리들과 각종 API, JVM을 의미한다. JRE는 개발(작성)은 안되고 실행(읽기)만된다.바이트코드 바이너리 코드가 컴퓨터가 인식할 수 있는 코드라면 바이트 코드는 가상머신이 인식할 수 있는 코드이다. 자바 소스 파일이 컴파일 과정을 거치면 기계어는 아니지만 JVM이 이해할 수 있는 바이트코드가 된다. 자바 컴파일러에 의해 변환되는 코드는 1바이트라서 바이트코드라고 불린다. 이러한 자바 바이트코드의 확장자는 .class이다.🤷‍♂️그냥 바로 바이너리 코드로 컴파일 하면 되지 왜 JVM을 거쳐야만 할까? 운영체제 간에 결합성을 낮출수 있다. JVM은 운영체제를 신경 쓰지않고 실행할수 있도록 도와준다. 코드를 재사용 하기 위해서.JVM에는 JIT 컴파일러가 있다. JIT 컴파일러는 중복되는 바이트코드를 얼마나 중복되는지 확인하고 일정 기준을 넘는다면 저장해 두어 재사용 할 수 있다.JIT 컴파일러인터프리터는 명령어를 하나씩 실행한다. 그러다 보니 각각의 명령어 단위로 본다면 컴파일 언어보다 빠르지만 전체적으로 봤을 때 컴파일러 보다 상대 적으로 실행 속도가 느렸다. 중복되는 코드가 있더라도 라인별로 실행했기 때문에 중복된 부분을 구분할 수 없었기 때문이다.JIT(Just-In-Time) 적기 공급, 무재고 방식을 말한다. 다시 말해 재고를 쌓아 두지 않고 필요한 만큼만 생성해서 사용한다는 의미다. JIT 컴파일러는 인터프리터 처럼 한줄 씩 실행한다. 한줄 씩 캐시에 기계어로 저장해 두었다가 같은 명령어가 나오면 캐시에 저장되었던 기계어를 사용하게 된다. 인터프리터 컴파일러는 처음부터 끝까지 기계어로 번역하고 실행하는 하는 반변 인터프리터는 코드를 한 줄씩 읽어 내려가며 실행하는 프로그램이다. 파이썬과 자바스크립트는 인터프리터 언어다. JVM 구성 요소1. Class Loaderclass 파일이 된 바이트코드를 JVM이 운영체제로 부터 할당받은 공간 Runtime Date Area로 전달하는 역할을 한다.2. Execution Engine JIT컴파일러를 활용하여 .class 바이트코드를 명령어 단위로 읽어 실행한다.3. Garbage Collector 힙메모리는 클래스로 부터 생성된 객체들의 메모리가 존재하는 공간이다. Garbage Collector(GC)는 힙메모리에 있는 객체들이 참조되고있는지 판별하여 아무도 참조하고 있지 않아 쓸모가 없다면 힙메모리 영역에서 객체를 삭제한다.4. Runtime Data AreaJVM의 메모리 영역으로 자바를 실행할때 사용되는 메모리가 저장되어 있는 공간이다. 메모리의 종류는 크게 Method Area, Heep Area, Stack Area, PC Register, Native Method Stack로 나눠진다.1) Method(Static) Area JVM이 읽어들인 클래스와 인터페이스, 런타임 상수 풀, 맴버 변수(필드), Static 변수, 생성자와 메소드를 저장하는 공간2) Heep Area new 연산자로 생성된 객체들 또는 인스턴스와 배열을 저장한다. 배열 또한 new ArrayList로 시작되는 객체 이다. 그냥 new를 통해 생성되는 모든 객체들이 저장되는 공간이다. 객체들이 생성과 동시에 인스턴스 변수를 초기화 할수 있는 생성자도 결국 하나의 객체안에 포함되는 개념이기 때문에 생성자로 초기화된 변수 값들도 힙 영역에 저장된다.3) JVM Stacks쓰레드는 프로그램을 실행하는 단위이며, 실행하는 주체다. JVM Stacks는 그런 쓰레드의 영역이다. 스레드를 생성하지 않았다면 main 스레드만 존재 한다. main 메서드를 호출하면 stack프레임을 생성하게 되고 그안에서 실행되는 지역변수를 저장하게 된다. 이때 기본 자료형은 변수의 값 그데로 같이 저장되지만 참조형 자료형은 변수에 실제 데이터의 주소 값만 갖게된다. 실제 데이터는 heep영역에 생성된다.스택메모리는 메소드의 호출과 함께 할당되고 메소드의 호출이 완료되면 소멸한다.예시 class Car { private String modelName; private int modelYear; private String color; private int maxSpeed; private int currentSpeed; Car(String modelName, int modelYear, String color, int maxSpeed) { this.modelName = modelName; this.modelYear = modelYear; this.color = color; this.maxSpeed = maxSpeed; this.currentSpeed = 0; } public String getModel() { return this.modelYear + \"년식 \" + this.modelName + \" \" + this.color; }} public class Method02 { public static void main(String[] args) { Car myCar = new Car(\"아반떼\", 2016, \"흰색\", 200); // 생성자의 호출 System.out.println(myCar.getModel()); // 생성자에 의해 초기화되었는지를 확인함. }}4) PC Registers소프트웨어는 명령어와 데이터로 이루어져있다. 프로그램 카운터 에서는 데이터들을 처리할 명령어를 저장하는 공간이다.5) Native Method Stack자바가 아닌 다른언어로 작성된 네이티브 메서드를 지원하기 위해 사용되는 스택이다.컴파일 하는 방법자바에서 컴파일 하는 방법으로는 두가지가 있다. 하나는 Java Compiler(javac), 나머지 하나는 JIT 컴파일러다javac로 컴파일 하는 법Hello.java 파일을 생성한다.public class Hello { public static void main(String args[]){ System.out.println(\"Hello,Java\"); }}cmd에서 javac Hello.java 명령어를 입력하여 컴파일 한다.바이트코드인 .class파일이 생성된다javap 명령어로 실행하게 되면 사람이 읽을 수 있는 형태로 출력되게 된다.위 코드를 OP코드(operation code)라고 한다.클래스 파일을 실행할 때는 java 클래스 파일명을 실행한다.🤷‍♂️만약 다른 버전의 자바컴파일러로 컴파일 했을 때 실행이 될까?상위 버전으로 컴파일한 .class 파일은 실행할수 없다. 하지만 하위 버전 컴파일러로 컴파일한 파일은 상위버전에서 실행이 가능하다.Error: A JNI error has occurred, please check your installation and try againException in thread \"main\" java.lang.UnsupportedClassVersionError: Hello has been compiled by a more recent version of the Java Runtime (class file version 61.0), this version of the Java Runtime only recognizes class file versions up to 52.0상위 버전으로 컴파일 하고 하위버전에서 실행했을 때 출력되는 에러 메세지를 기억해 두자. 스프링이나 라이브러리가 자신이 쓰고 있는 자바 버전보다 상위의 버전으로 패키징하였을 경우 위와 같은 에러 메세지가 출력될 수 있다.🤷‍♂️상위 버전에 컴파일러로 컴파일 하더라도 실행되도록 할 수 있을까?컴파일 할때 컴파일 옵션을 주면된다. -source, -target 옵션으로 실행가능하도록 할 버전을 선택한다.javac -source 1.8 -target 1.8 Hello.javawarning: [options] bootstrap class path not set in conjunction with -source 81 warning컴파일은 잘되지만 위와 같은 경고 메세지가 나온다. 실행가능하도록 할 버전의 rt.jar위치를-bootclasspath옵션을 주어 표시해 한다.javac -source 1.8 -target 1.8 Hello.java -bootclasspath C:\\Users\\Owner\\java8\\lib\\rt.jar Hello.java이제 경고메시지도 출력되지 않고 하위 버전으로 실행해도 잘 동작한다." }, { "title": "[자바]ArrayList", "url": "/posts/JAVAList/", "categories": "JAVA", "tags": "제네릭, ArrayList, HashSet, 배열, Generics, Array", "date": "2022-06-08 00:00:00 +0900", "snippet": "배열(Array)일단 리스트를 설명하기 전에 배열을 간단하게 설명하자면int[] odds = {1, 3, 5, 7, 9};배열은 자료형 타입 바로 옆에 [] 기호를 사용하여 표현한다. 위 처럼 int의 자료형의 배열은 int[] 로 표기하여 사용하고 원소들은 자료형의 맞는 원소만이 들어올 수 있다.String[] weeks = new String[7];위와 같은 형식으로 배열의 길이를 미리 정할 수 있다. 여기서 배열의 핵심은 크기가 항상 고정되어 정해져있다는 것이다.리스트(List)리스트는 배열과 유사하다. 가장 큰 차이는 크기가 정해져 있지 않고 동적으로 변환한다는 점이다.ArrayListArrayList는 List 자료형 중에 하나로 가장 간단한 형태의 자료형이다.List 자료형List 자료형에는 ArrayList, Vector, LinkedList 등의 List 인터페이스를 구현한 자료형이 있다. 여기서 말하는 List 자료형은 인터페이스인데 인터페이스에 대해서는 뒤에서 자세히 다루도록 한다.addimport java.util.ArrayList;public class Sample { public static void main(String[] args) { ArrayList pitches = new ArrayList(); pitches.add(\"138\"); pitches.add(\"129\"); pitches.add(\"142\"); }}add메서드를 활용해 pitches 리스트에 원소를 넣을 수 있다. 만약 두개의 파라미터를 사용하면첫번째 인덱스는 넣어줄 위치 인덱스값 두번째 인자는 넣어줄 값이 된다.제네릭(Generics)ArrayList&lt;String&gt; pitches = new ArrayList&lt;String&gt;();&lt;&gt;안에 타입을 입력하여 배열의 타입을 선언할 수 있다.&lt;Integer&gt; &lt;생성한 클래스&gt; 등 어떤 자료형도 사용할 수 있다.HashSetSet 인터페이스의 대표적인 클래스 입니다. Set은 객체를 중복해서 저장할 수 없고 하나의 null 값만 저장할 수 있습니다. HashSet은 내부적으로 객체를 저장하기 전에 먼저 객체의 hashCode()메소드를 호출해서 해시코드를 얻어낸다음 저장되어있는 객체들의 해시 코드와 비교하여 같은 해시코드가 잆다면 equals()메소드로 두 객체를 비교하여 true가 나오면 동일한 객체로 판단하고 중복 저장을 하지 않는다.HashSet&lt;Integer&gt; set1 = new HashSet&lt;Integer&gt;();//HashSet생성" }, { "title": "[자바]콘솔 입출력", "url": "/posts/JAVAIO/", "categories": "JAVA", "tags": "Stream, InputStram, InputStreamReader, BufferedReader, Scanner, System.err", "date": "2022-06-07 00:00:00 +0900", "snippet": "콘솔 입력자바 코드에서 입력한 문자열을 얻기위해서는 자바의 System.in 을 사용한다import java.io.IOException;import java.io.InputStream;public class Sample { public static void main(String[] args) throws IOException { InputStream in = System.in; int a; a = in.read(); System.out.println(a); }}InputStream 은 자바의 내장 클래스이다. 자바의 내장 클래스중에 java.lang 패키지에 속해 있지 않은 클래스는 위 코드처럼 필요할 때 항상 improt 해서 사용해야한다.System이나 String 등의 클래스는 java.lang 패키지에 속해 있는 클래스이므로 별도의 import 과정이 필요없다System.in 은 InputStram 의 객체 이다. System.in을 사용하게 되면 콘솔창에서 입력 값을 받을 수 있다.InputStream에는 1byte의 사용자 입력값을 읽을 수 있는 read라는 메소드가 있다. read 메소드로 읽은 데이터는 byte자료형으로 저장되는 것이 아니라 int 자료형으로 저장된다. 만약 a를 입력했다면 a에 해당되는 아스키코드값인 97이 출력되게 된다.🙋그렇다면 만약 한글자가 아닌 abc를 입력하면 어떻게 될까?이번에도 마찬가지로 97이 출력되게 된다. 그이유는 InputStream의 read 메소드는 1 byte만 읽기 때문이다. 즉, 사용자는 “abc”라는 3 byte의 데이터를 전달했지만 프로그램에서는 처음 1 byte만 읽게 된다. 이렇게 입력된 데이터를 입력 스트림(Stram)이라고 한다. 스트림은 이어져 있는 데이터(byte)의 형태를 의미한다. 점프투 자바 💡 스트림(Stream) 이란?스트림을 가장 쉽게 이해하려면 수도꼭지를 생각하면 된다. 수도꼭지를 틀면 물이 나오고 수도꼭지를 잠그면 물이 나오지 않는다. A라는 곳에서부터 B라는 곳까지 수도관이 연결되어 있고 A에서 계속 물을 보낸다면 B에서 수도꼭지를 틀때마다 물이 나오게 될 것이다.여기서 스트림은 A수도관에서 B수도관으로 이동하는 물의 흐름이라고 할 수 있다.프로그래밍에서는 다음과 같은 것들을 스트림이라고 할 수 있다.- 파일 데이터 (파일은 그 시작과 끝이 있는 데이터의 스트림이다.)- HTTP 송수신 데이터 (브라우저가 요청하고 서버가 응답하는 HTTP 형태의 데이터도 스트림이다.)- 키보드 입력 (사용자가 키보드로 입력하는 문자열은 스트림이다.)🤷그렇다면 사용자가 3byte를 입력했을 때 3 byte를 전부 읽고싶다면 어떻게 해야할까?길이 3짜리 byte 배열을 만든후 read 메소드 입력값으로 전달하면 콘솔 입력이 해당 배열에 저장이 된다.import java.io.IOException;import java.io.InputStream;public class Sample { public static void main(String[] args) throws IOException { InputStream in = System.in; byte[] a = new byte[3]; in.read(a); System.out.println(a[0]); System.out.println(a[1]); System.out.println(a[2]); }}abc (입력)97 (출력)98 (출력)99 (출력)👉번외로 여기서 아무런 입력값도 입력하지 않고 엔터를 누르게되면 0이 3번 출력될거 같은데13 (출력)10 (출력)0 (출력)예상했던것과 달리 위와 같이 출력된다. 그 이유는 개행문자, 즉 컴퓨터에서 줄바꿈을 나타내는 제어 문자때문에 일어난일이다. Java에서 줄바꿈을 인식하는 문자 \\n 와 커서의 위치를 맨앞으로 옮기는 \\r 이 합쳐져서 이둘의 아스키 코드 값이 출력되게 된것이다.InputStreamReader하지만 읽어들인 값을 항상 아스키코드 값으로 해석해야 하는 방식은 여전히 불편하다.🙋‍♂️입력한 문자값을 그대로 출력해 볼 수 없을까?바이트 대신 문자로 입력 스트림을 읽으려면 InputStreamReader 를 사용하면 된다.import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;public class Sample { public static void main(String[] args) throws IOException { InputStream in = System.in; InputStreamReader reader = new InputStreamReader(in); char[] a = new char[3]; reader.read(a); //char의 배열은 String과 같다 System.out.println(a); }}InputStreamReader를 사용하기 위해 import 문이 하나 더 추가되었다. 그리고 InputStreamReader 객체를 생성할 때는 다음과 같이 생성자의 입력으로 InputStream 객체인 System.in이 필요하다.InputStreamReader reader = new InputStreamReader(System.in);이전에는 읽어들일 값을 byte배열로 선언했는데 InputStreamReader를 이용하면 다음처럼 byte 대신 char 배열을 사용할 수 있다.🙋‍♂️그냥 char로 형변환을 사용하면 되지 굳이 InputStreamReader가 필요할까?package Test;import java.io.IOException;import java.io.InputStream;public class Sample { public static void main(String[] args) throws IOException { InputStream in = System.in; byte[] a = new byte[3]; in.read(a); char[] b = new char[3]; for(int i=0; b.length &gt;i; i++) { \tb[i] = (char)a[i]; } System.out.println(b); }}abc (입력)abc (출력)원했던 결과 대로 잘 출력 되는 것을 볼 수 있다 하지만 한글을 사용하게된다면안녕 (입력)??? (출력)한글이 깨지게된다. 그 이유는 맨처음 말했던거 처럼 InputStram은 1byte씩 사용자 입력값을 읽게되는데 한글은 2byte가 묶여서 한글자가 되기 때문에 한글대신 ?가 출력되게 된것이다. InputStreamReader는 이러한 문제점을 해결해 준다.BufferedReader프로그램이 많이 개선되었지만 여전히 고정된 길이로만 스트림을 읽게 된다.🤷‍♂️반복문을 사용하지않고 사용자가 엔터키를 입력할 때까지 사용자의 입력을 전부 받아들일 수 없을까?BufferedReader 를 이용하면 가능하다!import java.io.IOException;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;public class Sample { public static void main(String[] args) throws IOException { InputStream in = System.in; InputStreamReader reader = new InputStreamReader(in); BufferedReader br = new BufferedReader(reader); String a = br.readLine(); System.out.println(a); }}BufferedReader는 객체 생성시 생성자의 입력값으로 InputStreamReader의 객체가 필요하다. BufferedReader의 readLine메소드를 이용하면 사용자가 엔터키를 입력할 때까지 입력했던 모든 문자열을 읽을 수 있다.BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 한줄로 표현이 가능하다총정리 InputStream - byte InputStreamReader - character BufferedReader - StringScannerJ2SE 5.0 부터 Scanner 라는 java.util.Scanner 클래스가 새로 추가되었다. Scanner 클래스를 이용하면 콘솔입력을 훨씬 쉽게 사용할 수 있다.import java.util.Scanner;public class Sample { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(sc.next()); }} Scanner를 사용하기 위해서 먼저 java.util.Scanner 클래스를 import 해야한다.Scanner 클래스는 생성자의 입력으로 System.in 을 필요로 한다.Scanner 객체의 next() 메소드는 단어 하나를 읽어들인다. 문자열을 읽어 들일려면 nextLine 숫자를 읽어 들일려면 nextInt를 사용하면된다.총정리 next - 단어 nextLine - 라인 nextInt - 정수콘솔 출력지금까지 System.out.println 메서드를 계속해서 사용해 왔다. System.out 은 PrintStream 클래스의 객체이다. 동일한 역할을 하는 객체로 System.err 도 있다. 다만 System.err 는 오류 메시지를 출력할 경우 사용된다." }, { "title": "[자바]문자열(String)", "url": "/posts/JAVAString/", "categories": "JAVA", "tags": "자료형, 문자열, equals, 문자열 포메팅, StringBuffer, stringBuilder", "date": "2022-06-06 00:00:00 +0900", "snippet": "문자열(String) 위 자료형은 원시(primitive) 자료형이다. 이런 자료형은 new 키워드로 값을 생성 할 수없다. 리터럴(literal)로만 값을 대입할 수 있다예시boolean result = true;char capitalC = 'C';int i = 100000;문자열문자열을 나타내는 자료형은 String이다. Stirng은 new 키워드로 String 클래스를 생성해서 사용할수 있고 리터럴로 사용할 수있다. 보토은 가급적이면 리터럴 방식으로 사용한다 가독성에 이점이 있고 컴파일 시에도 최적화에 도움을 준다고 한다.예시String a = \"Happy Java\"; //리터럴String a = new String(\"Happy Java\"); // String 클래스를 생성하여 대입문자열 내장 메서드equalsequals는 두개의 문자열이 동일한지 비교하여 결과값을 리턴한다.String a = \"hello\";String b = \"java\";String c = \"hello\";System.out.println(a.equals(b)); // false 출력System.out.println(a.equals(c)); // true 출력🤷 왜 굳이 비교연산자를 사용하지 않고 equals를 사용할까?== 연산자를 사용할 경우 String 클래스로 생성했을 때 문제가 발생할 수 있다.String a = \"hello\";String b = new String(\"hello\");System.out.println(a.equals(b)); // trueSystem.out.println(a == b); // falsea와 b는 값은 같지만 서로 다른 객체이다. == 은 동일한 객체인지를 판별하는 연산자이기 때문에 false를 리턴한다 그래서 문자열의 값을 비교할 때는 반드시 equlas를 사용해야한다.문자열 포메팅문자열 포메팅은 String.format 메소드를 사용한다 문자열 안에서 특정 값을 넣어주고 싶은 자리에 이스케이프 문자를 넣어 특정값과 결합된 문자열을 만들어 낼 수 있다.System.out.println(String.format(\"I eat %s apples.\", \"five\")); // \"I eat five apples.\" 출력문자열 포맷 코드 코드 설명 %s 문자열(String) %c 문자 1개(character %d 정수(Integer) %f 부동소수(floating-point) %o 8진수 %x 16진수 🤓여기서 재미있는 점은 %s 포맷코드는 어떤 형태의 값이든 문자열로 변환하여 쓰기 때문에 숫자값이든 소수값이든 상관없이 사용할 수 있다.System.out.println(String.format(\"I have %s apples\", 3)); // \"I have 3 apples\" 출력System.out.println(String.format(\"rate is %s\", 3.234)); // \"rate is 3.234\" 출력포맷 코드와 숫자 함께 사용System.out.println(String.format(\"%10s\", \"hi\")); // \" hi\" 출력숫자와 함께 사용하게되면 숫자만큼의 빈공간을 비워두고 출력하게 된다.System.out.println(String.format(\"%.4f\", 3.42134234)); // 3.4213 출력소수점 네번째 자리까지만 나타내고 싶은경우 %.4f 를 사용하여 나타 낼 수있다.System.out.printfSystem.out.printf 메서드를 사용하면 String.fomat 메소드 없어도 동일한 문자열 포메팅을 사용할 수 있다.System.out.printf(\"I eat %d apples.\", 3); // \"I eat 3 apples.\" 출력StringBuffer한번 생성된 String은 불변(immutable)하는 성격을 가지고 있다. 따라서 다음과 같이 작성 한다고 했을 떄String result = \"\";result += \"hello\";result += \" \";result += \"hi java\";System.out.println(result);결과값은 hello hi java 가 되겠지만 내부적으로 총 4개의 String객체가 생성된 것이다. 그렇게 된다면 메모리 낭비가 심하게 발생할 수 있다.이때 같은 동작을 StringBuffer로 하게되면 StringBuffer는 변경하능(mutable)하기 떄문에StringBuffer sb = new StringBuffer(); // StringBuffer 객체 sb 생성sb.append(\"hello\");sb.append(\" \");sb.append(\"hi java\");String result = sb.toString();System.out.println(result);객체는 총 한번만 생성된다.🙋 그럼무조건 StringBuffer를 사용하는 것이 좋을까?그건 상황에 따라 다르다. StringBuffer 자료형은 String 자료형보다 메모리 사용량도 많고 속도도 느리다. 따라서 문자열 추가 변경등의 작업이 지속적으로 많을 경우에는 StringBuffer를 사용하고 문자열 변경 작업이 거의 없는 경우에는 그냥 String을 사용하는 것이 유리하다.stringBuilderStringbuffer와 사용법이 동일한 StringBuilder가 있다 다만 둘의 차이점은 StringBuffer는 멀티 스레드 환경에서 동기화(Synchronzation)을 보장하고 StringBuilder는 StringBuffer보다 성능이 우수한 장점이 있다. 따라서 동기화필요 여부에 따라서 StringBuilder 혹은 StringBuffer를 적절하게 사용하는 것이 유리하다." }, { "title": "[자바스크립트] 정규표현식", "url": "/posts/javascriptRegex/", "categories": "Javascript", "tags": "프로그래머스, 코딩테스트, 정규표현식, 신규 추천 아이디", "date": "2022-03-31 00:00:00 +0900", "snippet": "[자바스크립트] 정규표현식프로그래머스 코딩테스트 신규 추천 아이디 문제를 풀었다, 나는 복잡하고 긴 코드를 짜서 풀었지만 정규 표현식만 사용하여 풀수 있다는 것에 충격을 받았다. 정규표현식이 특정한 패턴의 문자를 걸러내고 조합하는 코드를 짜는데 있어서 얼마나 유용하고 코드가 간결화해질 수 있는지 느껴서 포스팅 하게 되었다.신규 추천 아이디 문제1단계 new_id의 모든 대문자를 대응되는 소문자로 치환합니다.2단계 new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.3단계 new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.4단계 new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.5단계 new_id가 빈 문자열이라면, new_id에 \"a\"를 대입합니다.6단계 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다. 만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.7단계 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.파라미터로 랜덤한 인풋값을 넣었을 때 위 조건에 맞아 떨어지는 문자열이 리턴되어야한다.1단계모든 대문자를 소문자로 치환하는 함수 toLowerCase()함수를 적용하여 대문자로 변경한다.2단계알파벳, 소문자, 숫자, 하이픈(-), 언더바(_), 점(.) 을 제외한 나머지를 공백을 변환해 준다.[^문자] 괄호 안에 문자를 제외 한다는 의미이다.\\w 는 영어 알파벳, 숫자, 언더바(_)를 의미한다.replace() 함수를 이용해서 첫번째 인자로 모든 문자를 의미하는 g를 마지막에 포함한 /[^\\w-.]/g 두번째 인자로 바꿔줄 문장을 넣으면 되는데 저문자를 제외하고 나머지는 지울거기 때문에 ‘’ 공백을 넣어준다.replace(/[^\\w-.]/g,'')3단계이부분에서 필자는 반분문을 써서 해결했지만.. 정규 표현식을 사용하게 된다면 아주 간단하게 해결할 수 있다. 정규 표현식에서 일반 문자는 그냥 사용하면되지만 특수문자를 검색하게 될 경우 앞에 역슬래시() 를 붙여야한다. 정규 표현식에서 + 는 검색하는대상이 연속해서 중복되는 경우를 검색하게 된다. 예를 들어 /c+/ 하게되면 c가 한개 있는 경우와 ccc 이런식으로 여러개 나열된 경우를 하나로 검색하게 된다. 하지만 낱개의 글자가 아니라 단어나 문장일 경우는 () 괄호를 통해 검색해야 중복된 검색을 선택 할 수 있다. 말이 어려우니 예제로 넘어가자let ko = 'kkkkkkkokokokokkkkoko'ko = ko.replace(/k+/g, 'k') // kokokokokoko중복된 k가 한개로 사라졌다 +떄문에 k와 kkkk를 동일하게 검색대상이 된것이다. 낱개의 글자가 아니라 ko라는 단어를 적용해 보자let ko = 'kkkkkkkokokokokkkkoko'ko = ko.replace(/ko+/g, 'ko') //kkkkkkkokokokokkkkoko예상과는 다르게 ko가 중복되서 출력된다. 그이유는 ko라는 단어에 + 가 아닌 o라는 단어에 +가 되어 충복된 o을 ko로 변환 시킨 것이다이러한 문제를 해결하기 위해 그룹화() 시켜서 검색하게 된다.let ko = 'kkkkkkkokokokokkkkoko'ko = ko.replace(/(ko)+/g, 'ko') //kkkkkkkokkkko결론적으로 중복되는 . 을 하나로 변경하기 위해서는 점(.)은 특수 문자기 때문에 역슬래시()가 앞에 붙어야 일반문자로 인식한다.replace(/\\.+/g, '.')4단계시작을 의미하는 ^문자열 과 마지막을 의미하는 문자열$ 을 정규표현식에서 OR을 의미하는 | 을 사용해서 첫번째 또는 마지막 쩜을 공백으로 변환시킨다.replace(/^\\.|\\.$/g, '')5단계시작과 마지막이 공백일 경우를 의미하는 검색패턴 ^$replace(/^$/g, 'a')6단계6단계 첫 번째 조건인 15개의 문자를 제외한 나머지를 지우기.slice(0, 15)두 번째 조건문자의 마지막이 점(.)일경우 제거.replace(/\\.$/g, '')7단계7단계는 반복문을 사용해서 푸는게 젤 이상적인 방법인거 같다. 하지만 주제가 정규표현식으로 해결하기이니 만큼 정규표현식을 사용해보자, $숫자 는 그룹조건을 의미한다. 예를 들어 $1 이라고 했을 때 첫번 째 그룹화된 조건을 의미하게 되고 $2라고 했을 때는 다음으로 그룹화된 검색 조건을 의미한다.var str = \"JohnSmith\"; var newstr = str.replace(/(Jo)(hn)/g, \"$2$1\"); //hnJoSmith첫 번째 그룹화된 문자는 Jo 이고 두번째 그룹화된 문자는 hn이다. 그래서 코드를 해석해보자면 John을 hnJo로 바꿔라가 되는 것 이다.이러한 특징을 이용해 7단계 문제를 정규식으로 풀어보자역슬래시 점이 아닌 특수문자로써 . 은 모든 문자열을 의미한다. 시작과끝에 문자열이 하나밖에없다면 그문자열을 3개로 만든다.replace(/^(.)$/g, '$1$1$1')시작과 끝에 문자열이 2개밖에 없다면 2번째 문자로 3개의 문자열로 만든다.replace(/^(.)(.)$/g, '$1$2$2')정규표현식정규표현식은 “특정 패턴의 문자”를 찾기 위한 표현 방식입니다. 정규 표현식을 사용하여 단순한 패턴을 검색하고자 할 때는 찾고자 하는 문자열을 직접 나열하면 됩니다. 하지만 숫자만을 검색하거나, 띄어쓰기를 찾는 등 정확히 일치하는 패턴보다 더 복잡한 조건을 사용하려면 특수 문자를 사용해야 합니다.정규표현식 사용법1. 정규 표현식 형식/패턴/플래그 슬래시(/) 사이에는 매칭시킬 패턴을 써준다. 슬래시(/) 다음에는 옵션을 설정하는 플래그를 써준다. 패턴은 찾고자하는 특정 패턴의 문자를 말하는 것이고 플래그는 하나만 찾을지, 모두 다 찾을지 등을 설정하는 옵션이라고 보면된다.2. 정규표현식 매칭 패턴종류 패턴 의미 a-zA-Z 영어알파벳(-으로 범위 지정) ㄱ-ㅎ가-힣 한글 문자(-으로 범위지정) 0-9 숫자(-으로 범위 지정) . 모든 문자열(숫자, 한글, 영어, 특수기호, 공백 모두 단, 줄바꿈X) \\d 숫자 \\D 숫자가 아닌것 \\w 영어 알파벳, 숫자, 언더스코어(_) \\W 영어 알파벳, 숫자, 언더스코어(_)가 아닌것 \\s space 공백 \\S space 공백이 아닌것 \\특수기호 특수기호 \\ 역슬래시() 다음에 일반 문자가 나오면 이스케이프문자로 해석하고, 특수 문자가 나오면 일반 문자로 해석한다. 3. 정규표현식 검색 패턴 기호 의미       OR [] 괄호안의 문자들 중 하나   [^문자] 괄호안의 문자를 제외한 것   ^문자열 특정 문자열로 시작(괄호 없음 주의)   문자열$ 특정 문자열로 끝남   () 그룹 검색 및 분류(match메서드에서 그룹별로 묶어줌)   (?: 패턴) 그룹 검색(분류X)   \\b 단어의 처음/끝   \\B 단어의 처음/끝이 아님   4. 정규표현식 갯수(수량) 패턴 특정 패턴이 몇번 반복되는지 필터링하는 역할을 한다. 기호 의미 ? 최대 한번(없음 or 한개) * 없거나 있거나(없음 or 있음): 여러개 포함 + 최소 한개(한개 or 여러개) *? 없거나,있거나 &amp;&amp; 없거나, 최대한개=없음 {0}과 동일   +? 최소한개,있거나 &amp;&amp; 없거나,최대한개 = 한개 {1}과 동일   {n} n개 {Min,} 최소 Min개 이상 {Min, Max} 최소 Min개 이상, 최대 Max개 이하 5. 정규표현식 플래그 플래그는 동시에 여러개를 조합하여 사용할 수 있다. 예) gi, gm 등 플래그 의미 g Global: 모든 문자 검색(안 쓰면 매칭되는 첫 문자만 검색) i Ignore Case: 대소문자 구분 안함 m Mult line: 여러 행의 문자열에 대해 검색 s .(모든 문자 정규식)이 개행 문자 \\n도 포함하도록 한다. u unicode 유니코드 전체를 지원 y sticky 문자 내 특정 위치에서 검색을 진행하는 ‘sticky’ 모드 활성화 " }, { "title": "MVC 패턴", "url": "/posts/MVCpattern/", "categories": "개발 지식", "tags": "MVC, 모델, 뷰, 컨트롤러, Model, View, Controller", "date": "2022-03-31 00:00:00 +0900", "snippet": "MVC패턴디자인 패턴 MVC패턴은 디자인패턴 중 하나입니다.디자인 패턴이란 프로그램이나 어떤 특정한 것을 개발하는 중에 발생했던 문제점들을 정리해서 상황에 따라 간편하게 적용해서 쓸 수 있는 것을 정리하여 특정한 “규약”을 통해 쉽게 쓸 수 있는 형태로 만드는 것을 말합니다.다른이들과 공유를 하면서 프로젝트를 진행할 때 좀더 쉽고 깔끔하게 만들 수 있는 방법을 고안해야 됩니다. 이러한 방법들이 명확하지 않다면 우리는 클래스 함수들을 일일히 다 만들어야 합니다. 그 방법을 고안하기 위한 방법 중 라이브러리나 프레임워크가 그에 따른 예입니다.나중에 유지보수하기 쉽고 편리하게 사용할 수 있게 만든 특정한 방법들을 디자인 패턴 이라고 합니다.MVC란 Model, View, Controller의 약자입니다 하나의 애플리케이션, 프로젝트를 구성할 때 그 구성 요소를 세가지의 역할로 구분한 패턴입니다.위의 그림처럼 사용자가 controller를 조작하면 controller는 model을 통해서 데이터를 가져오고 그 정보를 바탕으로 시각적인 표현을 담당하는 View를 제어해서 사용자에게 전달하게 됩니다.01 모델, Model 애플리케이션의 정보, 데이터베이스, 처음정의 하는 상수, 초기화 값, 변수 등을 뜻합니다. 또한 이러한 정보들의 가공을 책임지는 커포넌트를 말합니다. 이 모델은 다음과 같은 규칙을 가지고 있습니다.1. 사용자가 편집하길 원하는 모든 데이털르 가지고 있어야 한다. 즉, 화면안의 네모박스에 글자가 표시된다면, 네모박스의 화면 위치 정보, 네모박스의 크기정보, 글자내용, 글자의 위치, 글자의 포맷 정보 등을 가지고 있어야 한다.2. 뷰나 컨트롤러에 대해서 어떤 UI도 관여할 수 없다. 데이터 변경이 일어났을 때 모델에서 화면 UI를 직접 조정해서 수정할 수 있도록 뷰를 참조하는 내부 속성값을 가지면 안된다.3. 변경이 일어나면, 변경에 대한 처리방법을 구현해야 한다. 모델의 속성 중 텍스트 정보가 변경이 된다면, 이벤트를 발생시켜 누군가에게 전달해야 하며, 누군가 모델을 변경하도록 요청하는 이벤트를 보냈을 때 이를 수신할 수 있는 처리 방법을 구현해야 합니다. 또한 모델은 재사용가능해야 하며 다른 인터페이스에서도 변하지 않아야 합니다.02. 뷰, View input 텍스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타냅니다. 다시 말해 데이터및 객체의 입력, 그리고 보여준는 출력을 담당합니다. 데이터를 기반으로 사용자들이 볼 수 있는 화면 입니다.1. 모델이 가지고 있는 정보를 따로 저장해서는 안된다. 화면에 글자를 출력하기 위해, 모델이 가지고 있는 정보를 전달받게 된다. 그 정보를 유지하기 위해서 임의로 저장해서는 안된다. 단순히 네모박스를 그리라는 명령을 받으면, 화면에 표시하기만 하고 그 화면을 그릴 때 필요한 정보들을 저장하지 않아야된다.2. 모델이나 컨트롤러와 같이 다른 구성요소들을 몰라야 된다. 모델과 같은 자기 자신을 빼고는 다른 요소는 참조하거나 어떻게 동작하는지 않아서는 안된다.3. 변경이 일어나면 변경통기에 대한 처리방법을 구현해야 한다. 모델과 같이 변경이 일어났을 때 누군가에게 변경을 알려줘야 한는 방법을 구현해야 한다.03. 컨트롤러, Controller 데이터와 사용자인터페이스 요소들을 잇는 다리역할을 합니다. 즉, 사용자가 데이터를 클릭하고, 수정하는 것에 대한 “이벤트”들을 처리하는 부분을 뜻합니다. 컨트롤러 또한 다음과 같은 규칙을 이해 해야됩니다.1. 모델이나 뷰와 같이 다른 구성요소들의 정보를 알고 있어야 한다. 모델이나 뷰는 서로의 존재를 모르고, 변경을 외부로 알리고, 수신하는 방법만 가지고 있는데 이를 컨트롤러가 중재하기 위해 모델과 그에 관련된 뷰에 대해서 알고 있어야 합니다.2. 모델이나 뷰의 변경을 모니터링 해야한다. 모델이나 뷰의 변경 통지를 받으면 이를 해석해서 각자의 구성 요소에게 통지를 해야합니다. 또한, 애플리케이션의 메인 로직은 컨트롤러가 담당하게 된다.MVC 패턴을 사용해야 하는 이유 비즈니스 로직과 UI로직을 분리하여 유지보수를 독립적으로 수행가능 Model과 View가 다른 컴포넌트들에 종속되지 않아 애플리케이션의 확장성, 유연성에 유리하다 중복 코딩의 문제점을 제거한다.MVC 패턴의 의의 MVC패턴은 결국 “어떻게 나눌 것인가”에 대한 해답 중 하나입니다. 어떤 특정한 역할들에 대해 역할 분담을 할 때 가이드라인을 제시하는 방법 중 하나가 바로 MVC패턴이라는 것입니다." } ]
